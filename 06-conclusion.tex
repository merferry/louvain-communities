In conclusion, this study addresses the design of high-speed community detection algorithms in the shared memory setting. First, we present our optimized parallel implementation of the \textit{Louvain} algorithm, which obtains high-quality communities in a decent amount of time. On a server with dual 16-core Intel Xeon Gold 6226R processors, it identifies communities on an undirected web graph with $1.9$ billion edges in $6.8$ seconds, and thus achieving a processing rate of $560$ million edges/s. Next, we present our parallel implementation of \textit{LPA}, which obtains medium-quality communities in high speed. On the same server, it identifies communities on the same undirected web graph with $1.9$ billion edges in $2.7$ seconds, and thus achieving a processing rate of $1.4$ billion edges/s.

Next, we compare the performance of our Louvain with Vite (Louvain), Grappolo (Louvain), and NetworKit Louvain. Our Louvain is on average $50\times$, $22\times$, and $20\times$ faster than Vite, Grappolo, and NetworKit respectively. In addition, our Louvain on average obtains $3.1\%$ higher modularity than Vite (especially on web graph), and $0.6\%$ lower modularity than Grappolo and NetworKit (especially on social networks with poor clustering). Further, we compare the performance of our LPA with NetworKit LPA. Our LPA is on average $40.5\times$ faster than NetworKit, and is significantly faster on road networks and protein k-mer graphs (which have a low $|E|/|V|$ ratio). In addition, Our LPA on average obtains $4.1\%$ lower modularity than NetworKit, especially on protein k-mer graphs. We also attempt to compare with igraph LPA and Traag et al. FLPA, but find the runtime with both implementations to be extremely high.

Our Louvain achieves a strong scaling factor of $1.6\times$ for every doubling of threads, while our LPA achieves a strong scaling factor of $1.7\times$ for every doubling of threads. Looking ahead, future work could focus of designing dynamic algorithms for Louvain and LPA to accomodate dynamic graphs which evolve over time. This would contribute to rapidly / interactively updating of community memberships of vertices in many real-world scenarios (name a few).
